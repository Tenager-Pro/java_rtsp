package org.example;

public class JPEGHeader {
    //Интерпретация зависит от значения поля type. Если не указано ни одно
    // интерпретация, это поле ДОЛЖНО быть обнулено при
    // передаче и проигнорировано при приеме.

    private int TypeSpecific;
    // Смещение фрагмента - это смещение в байтах текущего пакета в
    // данных кадра JPEG. Это значение кодируется в сетевом порядке байтов
    // (сначала самый значимый байт). Смещение фрагмента плюс длина
    // данные полезной нагрузки в пакете НЕ ДОЛЖНЫ превышать 2 ^ 24 байта.
    private int FragmentOffset;

    // Типы 0-63
    // зарезервированы как фиксированные, хорошо известные сопоставления, которые будут определены в этом документе
    // и будущих редакциях этого документа. Типы 64-127 такие же, как и
    // типы 0-63, за исключением того, что в данных JPEG присутствуют маркеры перезапуска
    // а заголовок маркера перезапуска появляется сразу после основного
    // Заголовок JPEG. Типы 128-255 могут быть динамически определены с помощью
    // протокола настройки сеанса
    private int Type;

    // Поле Q определяет таблицы квантования для этого кадра.
    // Значения Q 0-127 указывают, что таблицы квантования вычисляются с использованием алгоритма,
    // определяемого полем Type Значения Q 128-255 указывают, что заголовок таблицы квантования
    // появляется после основного заголовка JPEG
    private int Q;

    // В этом поле кодируется ширина изображения, кратная 8 пикселям (например,
    // ширина 40 обозначает изображение шириной 320 пикселей). Максимальная ширина
    // равна 2040 пикселям
    private int Width;

    //Это поле кодирует высоту изображения в 8-пиксельных кратных
    // (например, высота 30 обозначает изображение высотой 240 пикселей). При
    // кодировании видео с чересстрочной разверткой это высота поля видео, поскольку
    // поля индивидуально кодируются в формате JPEG. Максимальная высота составляет 2040
    // пикселей.
    private int Height;

    private int RestartInterval;

    private int F;

    private int L;

    private int RestartCount;

    private int MBZ;
    private int Precision;
    private int Length;
    private byte[] QuantizationTableData;

    public int getTypeSpecific(){
        return TypeSpecific;
    }

    public int getFragmentOffset(){
        return FragmentOffset;
    }

    public int getType(){
        return Type;
    }

    public int getQ(){
        return Q;
    }

    public int getWidth(){
        return Width;
    }

    public int getHeight(){
        return Height;
    }


    public void parse(byte[] payload){
        TypeSpecific = (payload[0] & 0xFF); // Извлекаем интерпретацию
        Type = (payload[4] & 0xFF); // Извлекаем тип

        Q = (payload[5] & 0xFF);
        Width = (payload[6] & 0xFF);
        Height = (payload[7] & 0xFF);

        if (63<Type && Type<128){

        }
        else if (63<Type && Type<128) {

        }

    }
}
